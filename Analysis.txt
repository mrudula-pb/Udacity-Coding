
# Student provides a text file accurately explaining their run time analysis (Worst-Case Big-O Notation)
# for each solution they produced.

Task 0:
worse case complexity: O(1)
algorithm:
1. program simply prints the first row of texts.csv: O(1))
2.the last row of calls.csv: O(1))

Task 1:
worse case complexity: O(n^2)
algorithm:
1. initialise an empty set(complexity: O(1))
2. map through calls and texts to update set(complexity: O(n^2))
3. print resulting string to console(complexity: O(1))

Task 2:
worse case complexity: O(n^2)
algorithm:
1. initialise an empty set(complexity: O(1))
2. Map through calls and texts to update set(complexity: O(n^2))
3. Initialise an empty dictionary(complexity: O(1))
4. using nested for loop to update dictionary: O(n^2)
5. Initialise an empty dictionary(complexity: O(1))
6. Map through dict using for loop to update list (complexity: O(n))
7. print resulting string to console(complexity: O(1))

Task 3:
worse case complexity: O(n)
algorithm:
1. initialise an empty list(complexity:O(1))
2. initialise an empty set(complexity: O(1))
3. map through telephones_in_Bangalore to update list(complexity O(n))
2. map through updated list to update set(complexity: O(n))
5. count bangalore_call using for loop and find average(complexity O(n))
3. print resulting string to console(complexity: O(1))

Task 4:
worse case complexity: O(n^2)
algorithm:
1. initialise two empty set(complexity: O(1))
2. initialise two empty list(complexity: O(1))
3. Map through calls to update both set(complexity: O(n^2))
3. Map through texts to update both set(complexity: O(n^2))
4. Map both set through list1 to update list2 (complexity: O(n))
2. Map through calls and texts to update set(complexity: O(n))
3. print resulting string to console(complexity: O(1))